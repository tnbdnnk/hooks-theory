# Sing up form:
- потрібно зберігати певні дані в локал сторадж кожен раз, коли оновлюється або емайл або пароль;
- при перезавантаженні сторінки дані мають зберігатись на тому ж місці;

# Clock
Робота з рефами

Маємо: клас, який зберігає:
- стан state,
- інтервал(локальна змінна),
- при componentDidMount() запускається інтервал,
- при componentWillUnmount() інтервал зупиняється 

Рефакторинг:
- з класу робимо функцію
- потріно зберігати state (import)
- прописуємо state time в функції 
- new Date() - початкове значення. Виклик від new Date() - це виклик конструктора, тобто створення об'єкту, і кожен раз при рендері цього об'єктуб тобто кожен раз, коли буде змінюватись час початкове значення (new Date()) буде змінюватись
- лінива ініціалізація: useState(new Date()) -> useState(() => new Date()) - ця функція викличення лише раз, і те значення, яке вона поверне, буде використане для стану state

Remember: якщо початкове значення state залежить від виразу, треба робити ліниву ініціалізацію (передавати фукцію, яка буде повертати результать цього виразу, щоб воно не викликалось кожен раз)

- з intervalId робимо перемінну 
- componentDidMount -> useEffect()
- при першому рендері пустий масив залежностей useEffect(() => {}, [])
- кожен раз, як запускається ефект, в цьому випадку лише раз на першому рендері, в перемінну intervalId записується id інтервалу, цей інтервал відбувається кожні 1000 мілісекунд, в setTime йде новий new Date()
- stop - це функція. яка буде зупиняти інтервал. Під час stop intervalId буде очищено.

Reminder: під час роботи з класами intervalId була властивість екземпляру, властивість об'єкту, воно ініціалізовувалось один раз при його створенні, і потім в цього об'єкту викликався метод render(). В функціях тіло функції виконується повністю, коли змінюються або пропси, або стейт, і значення змінної intervalId на наступному рендері буде зовсім іншою змінною, зовсім іншим значенням, з попереднього рендеру неможливо отримати ніяких данних.
Якщо винести intervalId ззовні функції: наприклад якщо буде два таймери, ця змінна залишається єдиною для всього коду, і вона буде використовуватися лише в одному з таймерів, буде зберігати дані для останнього таймера, тому другий можливо буде зупинити, а перший ніяк.

Для того, щоб імітувати властивість, тобто для того, щоб імітувати (зберегти значення з попередного рендеру), тобно зробити стабільне значення між рендерами використовуються рефи. 
Взагалі рефи використовуються, щоб отриматти посилання на якийсь дом-вузол, але рефи не оновлюються, не обнуляються, вони створюються лише раз.
Тому в реакті є useRef(). Реф - це можливість зберегти посиланн на дом-елемент.

- let intervalId = null; -> const intervalId = useRef(null); В перемінну intervalId запишеться об'єкт, в якого буде властивість current. useRef() не буде викликатися на кожному виклиці функції, він викликається лише раз на першому рендері. В перемінній intervalId буде зберігатись старий об'єкт, який було створено при першому рендері
- useEffect(() => {
        intervalId = setInterval(() => {
            console.log('This inteval is every 1000s ' + Date.now());
            setTime(new Date());
        }, 1000);
    }, []);  ->  useEffect(() => {
        intervalId.current = setInterval(() => {
            console.log('This inteval is every 1000s ' + Date.now());
            setTime(new Date());
        }, 1000);
    }, []); - коли запускається ефект, на його реф, значення карент записується id інтервалу.
- const stop = () => {
        clearInterval(intervalId);
    }  ->  const stop = () => {
        clearInterval(intervalId.current);
    } - записаний айді в інтервал буде очищатись без проблем на будь якому годиннику, якщо їх в коді декілька

Issue: не зупинявся таймер.
Проблема з вашим кодом полягає в тому, що ви використовуєте константу (intervalId) для зберігання ідентифікатора, який повертає setInterval. Коли компонент повторно рендериться, intervalId створюється заново, а посилання на попередній інтервал втрачається. Як наслідок, виклик clearInterval із новим intervalId не зупиняє попередньо розпочатий інтервал.
Щоб вирішити цю проблему, ви можете використати хук useRef та ініціалізувати його значенням null. Потім, коли компонент монтується, ви можете призначити результат setInterval поточній властивості intervalId ref. Таким чином, intervalId ref зберігатиметься в рендерах.
ADD: return () => clearInterval(intervalId.current);

Потрібно зробити щось типу анмаунт. Коли розмонтовується компонент, його треба підчищати, щоб надалі не заважало роботі, та дані не записувались і не передавались на інші об'єкти. 

Під час роботи з классами використовувалось     
    componentWillUnmount() {
        console.log('This method is called before unmounting of component');
        this.stop();
    }
а з хуку useEffect можна поверати функцію, очищаюча функція return () => clearInterval(intervalId.current); 